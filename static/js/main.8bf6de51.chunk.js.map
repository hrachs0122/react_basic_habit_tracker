{"version":3,"sources":["components/simpleHabit.jsx","components/habit.jsx","components/habitAddForm.jsx","components/habits.jsx","components/navbar.jsx","app.jsx","index.js"],"names":["SimpleHabit","props","useState","count","setCount","spanRef","React","useRef","handleIncrement","useCallback","useEffect","console","log","className","ref","onClick","Habit","onIncrement","habit","handleDecrement","onDecrement","handleDelete","onDelete","this","name","PureComponent","HabitAddForm","memo","inputRef","createRef","onSubmit","event","preventDefault","current","value","onAdd2","type","placeholder","Habits","handleAdd11","onAdd1","habits","map","id","onReset","Component","Navbar","totalCount","ReactDOM","render","StrictMode","document","getElementById","array","array2","array3","push","length"],"mappings":"wNAgCeA,EA9BK,SAAAC,GAElB,MAA0BC,mBAAS,GAAnC,mBAAOC,EAAP,KAAcC,EAAd,KACMC,EAAUC,IAAMC,SAIhBC,EAAkBC,uBAAY,WAClCL,EAASD,EAAQ,MAQnB,OAJAO,qBAAU,WACRC,QAAQC,IAAR,gCAAqCT,MACpC,IAGD,qBAAIU,UAAU,QAAd,UACE,sBAAMC,IAAKT,EAASQ,UAAU,aAA9B,qBADF,IAEE,sBAAMA,UAAU,cAAhB,SAA+BV,IAFjC,IAGE,wBACEU,UAAU,8BACVE,QAASP,EAFX,SAIE,mBAAGK,UAAU,6B,2CCmCNG,G,kNA/CbR,gBAAkB,WAChB,EAAKP,MAAMgB,YAAY,EAAKhB,MAAMiB,Q,EAKpCC,gBAAkB,WAClB,EAAKlB,MAAMmB,YAAY,EAAKnB,MAAMiB,Q,EAMlCG,aAAe,WACb,EAAKpB,MAAMqB,SAAS,EAAKrB,MAAMiB,Q,uDAzBjC,WACEP,QAAQC,IAAR,iBAAsBW,KAAKtB,MAAMiB,MAAMM,KAAvC,e,kCAEF,WACEb,QAAQC,IAAR,iBAAsBW,KAAKtB,MAAMiB,MAAMM,KAAvC,oB,oBAwBF,WACI,MAAsBD,KAAKtB,MAAMiB,MAA1BM,EAAP,EAAOA,KAAMrB,EAAb,EAAaA,MAEb,OACM,qBAAIU,UAAU,QAAd,UACE,sBAAMA,UAAU,aAAhB,SAA8BW,IADhC,IAEE,sBAAMX,UAAU,cAAhB,SAA+BV,IAFjC,IAGE,yBACEU,UAAU,8BACVE,QAASQ,KAAKf,gBAFhB,cAIE,mBAAGK,UAAU,0BAEf,wBACEA,UAAU,8BACVE,QAASQ,KAAKJ,gBAFhB,SAIE,mBAAGN,UAAU,0BAEf,wBACEA,UAAU,4BACVE,QAASQ,KAAKF,aAFhB,SAIE,mBAAGR,UAAU,0B,GApDTY,kBCwBLC,EAxBMC,gBAAK,SAAC1B,GACvB,IAAM2B,EAAWtB,IAAMuB,YASvB,OACI,uBAAMhB,UAAU,WAAWiB,SARd,SAAAC,GACbA,EAAMC,iBACN,IAAMR,EAAOI,EAASK,QAAQC,MAC9BV,GAAQvB,EAAMkC,OAAOX,GACrBI,EAASK,QAAQC,MAAQ,IAIzB,cAEI,uBACIpB,IAAKc,EACLQ,KAAK,OACLvB,UAAU,YACVwB,YAAY,UAEhB,wBAAQxB,UAAU,aAAlB,uBCgCGyB,E,4MA9CX9B,gBAAkB,SAACU,GACf,EAAKjB,MAAMgB,YAAYC,I,EAG3BC,gBAAkB,SAACD,GACf,EAAKjB,MAAMmB,YAAYF,I,EAG3BG,aAAe,SAACH,GACZ,EAAKjB,MAAMqB,SAASJ,I,EAGxBqB,YAAc,SAAAf,GACV,EAAKvB,MAAMuC,OAAOhB,I,4CAGtB,WAAU,IAAD,OACL,OACI,sBAAKX,UAAU,UAAf,UACI,cAAC,EAAD,CAAcsB,OAAQZ,KAAKgB,cAC3B,6BAIChB,KAAKtB,MAAMwC,OAAOC,KAAI,SAAAxB,GAAK,OAExB,aAF8B,CAE7B,EAAD,CAEIA,MAAOA,EACPD,YAAa,EAAKT,gBAClBY,YAAa,EAAKD,gBAClBG,SAAU,EAAKD,cAJVH,EAAMyB,SASnB,wBAAQ9B,UAAU,eAAeE,QAASQ,KAAKtB,MAAM2C,QAArD,8B,GAvCKC,aCWNC,E,4JAZX,WAEI,OACI,sBAAKjC,UAAU,SAAf,UACI,mBAAGA,UAAU,4BACb,iDACA,sBAAMA,UAAU,eAAhB,SAAgCU,KAAKtB,MAAM8C,oB,GAPtCtB,iBCGHoB,YCGlBG,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAG1B,IAAMC,EAAQ,CACZ,CAACV,GAAI,IAAKxC,MAAO,GACjB,CAACwC,GAAI,IAAKxC,MAAO,IAEbmD,EAASD,EACTE,EAAM,UAAOF,GAQnBA,EAAM,GAAGlD,MAAQ,EACjBQ,QAAQC,IAAIyC,EAAM,IAClB1C,QAAQC,IAAI0C,EAAO,IACnB3C,QAAQC,IAAI2C,EAAO,IAEnBF,EAAMG,KAAK,CAACb,GAAG,IAAKxC,MAAM,IAC1BQ,QAAQC,IAAIyC,EAAMI,QAClB9C,QAAQC,IAAI0C,EAAOG,QACnB9C,QAAQC,IAAI2C,EAAOE,U","file":"static/js/main.8bf6de51.chunk.js","sourcesContent":["import React, { useCallback, useEffect, useState } from 'react';\r\n\r\nconst SimpleHabit = props => {\r\n  \r\n  const [count, setCount] = useState(0);\r\n  const spanRef = React.useRef(); \r\n  // 매번 호출이될때마다 새로운 레퍼런스를 만드는걸 방지하기위해 createRef 대신 useRef 적용\r\n  // useRef 는 한번 만들어놓은 것을 메모리에 저장해 놓고 다시 그것을 재사용 함\r\n  \r\n  const handleIncrement = useCallback(() => {  \r\n    setCount(count + 1);\r\n  });\r\n  // 계속해서 새로 호출되는것을 방지하기 위해 useCallback 사용 하면 handleIncrement가 반복해서 호출을 하더라도 동일한 콜백함수를 전달한다\r\n  \r\n  useEffect(() => {\r\n    console.log(`mounted and updated!: ${count}`);\r\n  }, []); // 계속해서 업데이트가 되고, []사용하면 처음에만 호출됨\r\n  \r\n  return (\r\n    <li className=\"habit\">\r\n      <span ref={spanRef} className=\"habit-name\">Reading</span> {/* Reading이라고 초기에 적혀져 있는데 재사용력을 높이기 위해 데이터를 받아와서 사용하기 props로 전달 */}\r\n      <span className=\"habit-count\">{count}</span> {/* 숫자에서 {}를 이용하여 데이터 표기 */}\r\n      <button \r\n        className=\"habit-button habit-increase\"\r\n        onClick={handleIncrement}\r\n      >\r\n        <i className=\"fas fa-plus-square\"></i>\r\n      </button>\r\n    </li>\r\n  );\r\n};\r\n\r\nexport default SimpleHabit;\r\n\r\n\r\n\r\n//class Habit extends Component, Habit 이라는 컴포넌트는 자체적으로 가지고있는 상태(state)는 필요가 없고, \r\n// 외부에서 props로 전달받은 습관 this.props.habit;  habit이라는 오브젝트의 데이터를 보여주기만 하는 컴포넌트이다","import React, { PureComponent } from 'react';\r\n\r\nclass Habit extends PureComponent {\r\n  componentDidMount() {\r\n    console.log(`habit: ${this.props.habit.name} mounted`);\r\n  }\r\n  componentWillUnmount() {\r\n    console.log(`habit: ${this.props.habit.name} will unmount`);\r\n  }\r\n  // state = {\r\n  //   count: 0,\r\n  // };  부모컴포넌트로 부터 받아온 props로 인해 이부분은 보여지기만 하는곳으로 자체적으로 state가 필요가 없어짐\r\n\r\n  // handleIncrement라는 맴버변수는 화살표함수를 가리키고있는데 이 변수는 event를 받아서 increment를 처리해준다 \r\n  handleIncrement = () => { \r\n    this.props.onIncrement(this.props.habit); // habits.jsx에서 handleIncrement에서의 habit, 습관을전달해주는 인자 this.props.habit를 가져옴\r\n  };\r\n  // state 오브젝트 안에 있는 count를 증가 한 뒤 state를 업데이트 해야 함\r\n  // this.setState({ count: this.state.count + 1}); 핸들링하는 로직들은 지워줌\r\n  \r\n  handleDecrement = () => { \r\n  this.props.onDecrement(this.props.habit);\r\n  };\r\n  // const count = this.state.count - 1; // const 에 새호운 count라는 숫자를 (this.state.count - 1)이렇게 적용하는데, \r\n  // this.setState({ count: count < 0 ? 0 : count }); // count가 0 보다 작으면 0을 출력하게 하고 그렇지 않으면 새로운 count 출력하게 함 \r\n  // 핸들링하는 로직들은 지워줌\r\n  \r\n  handleDelete = () => {\r\n    this.props.onDelete(this.props.habit);\r\n  };\r\n\r\n  render() {\r\n      const {name, count} = this.props.habit; // 변수에 각각 name 과 count를 넣고 this.props에 있는 habit을 불러옴\r\n        \r\n      return (\r\n            <li className=\"habit\">\r\n              <span className=\"habit-name\">{name}</span> {/* Reading이라고 초기에 적혀져 있는데 재사용력을 높이기 위해 데이터를 받아와서 사용하기 props로 전달 */}\r\n              <span className=\"habit-count\">{count}</span> {/* 숫자에서 {}를 이용하여 데이터 표기 */}\r\n              <button \r\n                className=\"habit-button habit-increase\"\r\n                onClick={this.handleIncrement}\r\n              > {/* 콜백함수 불러주기 */}\r\n                <i className=\"fas fa-plus-square\"></i>\r\n              </button>\r\n              <button \r\n                className=\"habit-button habit-decrease\" \r\n                onClick={this.handleDecrement}\r\n              >\r\n                <i className=\"fas fa-minus-square\"></i>\r\n              </button>\r\n              <button \r\n                className=\"habit-button habit-delete\" \r\n                onClick={this.handleDelete}\r\n              >\r\n                <i className=\"fas fa-trash\"></i>\r\n              </button>\r\n            </li>\r\n          );\r\n    };\r\n}\r\n\r\nexport default Habit;\r\n\r\n//class Habit extends Component, Habit 이라는 컴포넌트는 자체적으로 가지고있는 상태(state)는 필요가 없고, \r\n// 외부에서 props로 전달받은 습관 this.props.habit;  habit이라는 오브젝트의 데이터를 보여주기만 하는 컴포넌트이다","import React, { memo } from 'react';\r\n\r\nconst HabitAddForm = memo((props) => { // {}처럼 코드블록 추가\r\n    const inputRef = React.createRef(); //ref 오브젝트 생성, inputRef 라는 이름의 맴버변수 를 사용하여 createRef 함수 호출\r\n\r\n    const onSubmit = event => {\r\n        event.preventDefault(); //onSubmit을 사용하면 기본적으로 브라우저기본기능인 refresh가 일어남으로 제어해줌\r\n        const name = inputRef.current.value; // habit의 이름은 inputRef안에 있는 value를 받아오기\r\n        name && props.onAdd2(name); // 이름이 있고, 비어진 값이 아니라면 props에 전달된 onAdd라는 함수에 name을 전달 하기\r\n        inputRef.current.value = '';\r\n    };\r\n\r\n    return (\r\n        <form className=\"add-form\" onSubmit={onSubmit}> {/* 버튼을누르면 onSubmit이라는 함수 호출 */}\r\n            {/* input의 요소가 위에 있는 inputRef와연결이 됨 이 요소에서 해당하는 데이터를 읽어올 수 있음 */}\r\n            <input\r\n                ref={inputRef} \r\n                type=\"text\" \r\n                className=\"add-input\" \r\n                placeholder=\"Habit\" \r\n            />\r\n            <button className=\"add-button\">Add</button>\r\n        </form>\r\n    );\r\n});\r\n\r\nexport default HabitAddForm;\r\n\r\n// react 에서는 dom요소를 직접적으로 쓰지 않기 때문에 \r\n// react 에서 다른 react 요소에 접근하고 싶을때 ref 를 사용\r\n\r\n// rsi 라는 단축키사용하여 함수형컴포넌트 오픈하고\r\n// const 변수를 앞에 공통적으로 사용\r\n// 모든 this는 다 지우기\r\n// 제일 상단에 purecomponent 지우기\r\n\r\n// 모든 함수 및 내용을 잘라내기 한 다음, memo를 입력해주면 자동으로 상단에도 {memo} 라고 설정되는것이 보임\r\n// memo(); 추가하여 ()안에 잘라진 함수들을 넣어주기\r\n// memo라는 함수 안에 function 컴포넌트를전달해줌 \r\n// memo는 purecomponent 처럼 props가 변경되지 않으면 안에 있는 함수가 호출이 되지않는다. purecomponent와 비슷","import React, { Component } from 'react';\r\nimport Habit from './habit';\r\nimport HabitAddForm from './habitAddForm';\r\n\r\nclass Habits extends Component {\r\n    // state = { }; app.jsx로 복사붙여넣기 한 후 지워줌\r\n\r\n    handleIncrement = (habit) => {\r\n        this.props.onIncrement(habit);\r\n    };\r\n    \r\n    handleDecrement = (habit) => {\r\n        this.props.onDecrement(habit);\r\n    };\r\n    \r\n    handleDelete = (habit) => {\r\n        this.props.onDelete(habit);\r\n    };\r\n    \r\n    handleAdd11 = name => {\r\n        this.props.onAdd1(name);\r\n    };\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"content\">\r\n                <HabitAddForm onAdd2={this.handleAdd11}/>\r\n                <ul>\r\n                {/* {this.state.habits.map((habit, index) => {\r\n                    return <Habit key={index} habit={habit} />\r\n                })} */}\r\n                {this.props.habits.map(habit => ( // habits.jsx에서 부모컴포넌트로 보내주기위해 app.jsx에 state적용 및 모든 이벤트들을 다 옮겨간 후, this.state에서 this.props로 적용함\r\n                    // 만들어놓은 Habit이라는 컴포넌트를 그대로 가져와서 사용함\r\n                    <Habit \r\n                        key={habit.id} \r\n                        habit={habit} \r\n                        onIncrement={this.handleIncrement} // 위에 함수들을 호출하기위해 전달해주기 onIncrement= 이라는 props로 전달된 아이를 {this.handleIncrement} 와같이 콜백함수로 전달함\r\n                        onDecrement={this.handleDecrement}\r\n                        onDelete={this.handleDelete}\r\n                    /> // habit= 이라는 prop 이름에 각각의 habit={habit} 데이터를 전달해줌 // 위에 배열데이터를 컴포넌트에 연결함 key안에는 habit안에있는ID를 지정해줌. index사용하지 말기\r\n                    \r\n                ))}\r\n                </ul>\r\n                <button className=\"habits-reset\" onClick={this.props.onReset}>\r\n                    Reset All\r\n                </button>\r\n            </div>\r\n        ); \r\n           \r\n        // JS코드를 사용할 것이기 때문에 {}를 해준 다음에 this에 state에 있는 habits를 map을 이용하여 적용해준데 ,각각의 habit을 JSX로 변환해준다\r\n    }\r\n}\r\n\r\nexport default Habits;\r\n\r\n// 리스트에서는 자식컴포넌트가 있다면 고유한 키를 가지고있어야 함,\r\n// 각각의 컴포넌트에 ID를 부여함으로 ID가 동일하다면 자식요소가 변화되어진것이 아니기 때문에 나중에 다른 자식요소가 추가되거나 \r\n// 위치가 변경되어도 아이디가 동일하다면 리액트가 불필요한 랜더링을 하지않는다든지 성능을 개선을 한다 ID부여가 중요함!\r\n\r\n// habit.jsx에서는 보여주기용도로?만 쓰인다면 여기에서 state영역은 데이터를 가지고 있는곳이 배열 데이터를 어떻게 수정하면되는지 잘 알수있는 영역이므로 여기서 수정하는것임. 그래서,\r\n// habit.jsx에 있는 세가지 함수를 그대로 복사해서 여기에 붙여옴","import React, { PureComponent } from 'react';\r\n\r\nclass Navbar extends PureComponent {\r\n    render() {\r\n        \r\n        return (\r\n            <div className=\"navbar\">\r\n                <i className=\"navbar-logo fas fa-leaf\"></i>\r\n                <span>Habit Tracker</span>\r\n                <span className=\"navbar-count\">{this.props.totalCount}</span>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Navbar;","import React, {Component} from 'react';\nimport './app.css';\nimport Habits from './components/habits';\nimport Navbar from './components/navbar';\n\nclass App extends Component {\n  state = {\n    habits: [ \n      // habits 이라는 이름의 배열안에 배열이 있는데 각각의 배열 안에는 habit이라는 오브젝트가 있음, 그리고 habit에는 이름과 count가 들어옴    // 배열 데이터\n        { id: 1, name: 'Reading', count: 0},\n        { id: 2, name: 'Running', count: 0},\n        { id: 3, name: 'Coding', count: 0},\n    ],\n  };\n\n  handleIncrement = habit => {\n    // const habits = [...this.state.habits]; // 배열을 복사해옴 ,state안에 있는 배열을 수정하면 안되기 때문에 ...을사용하여 배열을 복사해 옴\n    // const index = habits.indexOf(habit);\n    // habits[index].count++;\n    const habits = this.state.habits.map(item => {\n      if(item.id === habit.id) {\n        return {...habit, count: habit.count + 1};\n      }\n      return item;\n    });\n    this.setState({habits: habits}); // 새로운배열을 복사하여 만들었으므로 setState도 새로운배열을 만들어서 데이터를 지정해줘야함 {habits -> 키 : habits -> value}\n  };\n\n  handleDecrement = (habit) => {\n    // const habits = [...this.state.habits]; // 배열을 복사해옴\n    // const index = habits.indexOf(habit);\n    // const count = habits[index].count - 1;\n    // habits[index].count = count < 0 ? 0 : count;\n    const habits = this.state.habits.map(item => {\n      if(item.id === habit.id) {\n        const count = habit.count - 1;\n        return {...habit, count: count < 0 ? 0 : count };\n      }\n      return item;\n    });\n    this.setState({habits: habits});\n  };\n\n  handleDelete = (habit) => {\n    // 배열을 삭제하기 위해서 사용할 수 있는 함수를 생각해보고 어떻게 구현할지 생각하기\n    const habits = this.state.habits.filter(item => item.id !== habit.id); \n    // 새로운 로컬변수인 habits를 만들어서 this.state.habits의 item을 전달받아서 배열에 있는 item의 아이디가 삭제하고자하는 (habit)의 인자를 전달받은 id와 동일하지 않는 아이들만 가져오기\n    this.setState({habits: habits});\n\n  };\n  \n  handleAdd0 = name => { // habits에 있는 아이템들을 각각 복사함\n    const habits = [...this.state.habits, {id: Date.now(), name: name, count: 0}];\n    this.setState({habits: habits});\n  };\n\n  handleReset = () => {\n    const habits = this.state.habits.map( habit => {\n      // habit.count = 0;\n      // return habit;\n      if(habit.count !== 0) {\n        return {...habit, count: 0 };\n      }\n      return habit;\n    });\n    this.setState({habits});\n  };\n\n  render() {\n    \n    return (\n    <>\n      {/*this.state에 있는 habits 배열중에 filter를 사용함. item이 count가 0이상인 아이들을 현재진행중인 count가 0이상인 아이들을 filter해서 배열이 만들어지는것의 길이를 전달 */}\n      <Navbar totalCount={this.state.habits.filter(item => item.count > 0).length} />  \n      <Habits \n        habits={this.state.habits}\n        onIncrement={this.handleIncrement}\n        onDecrement={this.handleDecrement}\n        onDelete={this.handleDelete}\n        onAdd1={this.handleAdd0}\n        onReset={this.handleReset}\n      />\n    </>\n\n    ); //app.jsx에 state적용 및 모든 이벤트들을 다 옮겨서옴.. habit의 상태를 전달해줌.\n  }\n  \n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport '@fortawesome/fontawesome-free/js/all.js';\n// import App from './app';\nimport SimpleHabit from './components/simpleHabit';\nimport './app'\n\nReactDOM.render(\n  <React.StrictMode>\n    <SimpleHabit />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nconst array = [\n  {id: '1', count: 0},\n  {id: '2', count: 0},\n];\nconst array2 = array;\nconst array3 = [...array]; \n// array에있는 모든 아이템을 새로운 배열로 가지고 와서 새로운배열을을 만들어냄\n// 오브젝트는 그대로 두고 array배열을 돌면서 각각의 아이템들의 참조값을 복사함\n\n// [...array] 와 같은 spread operator 는 shallow-cloning을 한다\n// 배열안에 있는 오브젝트 및 그안에 들어있는 모든 오브젝트들까지 하나씩 바꿔주는것이 아니라,\n// 제일 상위의 배열껍데기만 새로운껍데기로 바뀌어지고 안의 오브젝트는 예전의 것을 참조값으로 복사해오기 때문\n\narray[0].count = 2;\nconsole.log(array[0]); // {id: \"1\", count: 2}\nconsole.log(array2[0]); // {id: \"1\", count: 2}\nconsole.log(array3[0]); // {id: \"1\", count: 2}\n\narray.push({id:'3', count:0});\nconsole.log(array.length); // 3\nconsole.log(array2.length); // 3\nconsole.log(array3.length); // 2 새로 추가된 아이템을 볼수 없다. array3은 새로운 완전히 다른 배열 오브젝트이기 때문\n"],"sourceRoot":""}